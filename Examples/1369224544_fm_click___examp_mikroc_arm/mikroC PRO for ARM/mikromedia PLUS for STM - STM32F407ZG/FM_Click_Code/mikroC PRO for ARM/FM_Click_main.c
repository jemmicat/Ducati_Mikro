/*
 * Project name:
     FM_Click.vtft
 * Generated by:
     Visual TFT
 * Revision History:
     20130520:
       - initial release (DO);
 * Description:
     This project is a simple demonstration of working with FM tunner Si4703
     Communication with FM module is established via I2C and radio inputs/outputs are displayed on screen.
 * Test configuration:
     MCU:             STM32F407ZG
                      http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/DM00037051.pdf
     dev.board:       mikromedia + for STM32
                      http://www.mikroe.com/mikromedia/plus/stm32/
     Oscillator:      HS-PLL 150.0000 MHz, 25.0000 MHz Crystal
     ext. modules:    FM click Board: ac:FM_click
                      http://www.mikroe.com/click/fm/
                      mikromedia + for STM shield : ac:mirkomedia_PLUS_for_STM_Shield
                      http://www.mikroe.com/mikromedia/plus/shields/stm32/
     SW:              mikroC PRO for ARM
                      http://www.mikroe.com/mikroc/arm/
 * NOTES:
     - Place FM click into mikroBUS socket 3 on mikromedia PLUS for STM Shiled.
 */

#include "built_in.h"
#include "FM_Click_objects.h"
#include "FM_Click_resources.h"

#define _FM_ADDRESS_  0x10     // 0x20 >> 1 = 0x10

#define _SET_ 1
#define _RESET_ 0
#define _FM_DIR_UP_ 1
#define _FM_DIR_DOWN_ 0

#define _FM_ALL_REG_ 0x0F
#define _FM_0A0B_REG_ 2

void Roller_Init();
char doTunner();
void Set_Tunner(int channel);

extern char Roll_flag;
char mylevel, my_old_level = 0xFF;
int channel;
char channel_offset = 9;

sbit FM_SEN   at GPIOA_ODR.B15;
sbit FM_RST   at GPIOB_ODR.B12;
sbit FM_SDIO  at GPIOF_ODR.B0;
sbit FM_SCK   at GPIOF_ODR.B1;
sbit FM_GP1   at GPIOE_ODR.B2;
sbit FM_GP2   at GPIOB_ODR.B1;

unsigned short powerOn = 0;
int Volume;
char  shadowReg[32];
char  test = 1;
unsigned int FMid;
unsigned int ChipID;
unsigned int oldFreq = 0;

void modShadowReg(unsigned short reg, unsigned int val, char set_reset) {
unsigned short reg_pos = 12;          // Index of 0x00 register in shadow register
                                      // Reading of Si4703 registers start from 0x0A-0x0F and then starts from 0x00-0x09
  reg_pos += reg << 1;                // Calculate position of register which needs to be modified
  if (set_reset == _SET_) {
    // Sets the desired bits in register
    shadowReg[reg_pos++] |= Hi(val);  // Split value to higher
    shadowReg[reg_pos]   |= Lo(val);  //   and lower nibble
  }
  else {
    // Resets the desired bits in register
    shadowReg[reg_pos++] &= ( ~ Hi( val ) );  // Split value to higher
    shadowReg[reg_pos]   &= ( ~ Lo( val ) );  //   and lower nibble
  }
}

void FM_Write(unsigned short reg, unsigned int val, char set_reset) {
unsigned short wr_cnt;

  wr_cnt = ( reg - 1 ) << 1;          // Calculate how much bytes need to be written
  modShadowReg(reg, val, set_reset);  // Modify register bytes
  I2C2_Start();
  I2C2_Write(_FM_ADDRESS_, &shadowReg[16], wr_cnt, END_MODE_STOP);   // Writing to register starts from 0x02 register
}

// Reading of registers starts from 0x0A register
void FM_Read(char cmd) {
  I2C2_Start();
  if (cmd == _FM_ALL_REG_)
    I2C2_Read(_FM_ADDRESS_, &shadowReg, 32, END_MODE_STOP);
  else if(cmd == _FM_0A0B_REG_)
    I2C2_Read(_FM_ADDRESS_, &shadowReg, 4, END_MODE_STOP);  // Read only STATUS and READCHAN registers
}

void SetVolume(unsigned short vol) {
  if ( ( vol >= 0 ) && ( vol <= 16) ) {
    vol &= 0x0F;
    modShadowReg(0x05, 0x000F, _RESET_);
    FM_Write(0x05, vol, _SET_);     // Write Volume value to SYSCONFIG2 register
  }
}

void Update_StereoIcon() {
char ST_bit;

  // Clear Stereo Icon
  TFT_Set_Brush(1, 0x3186, 0, 0, 0, 0);
  TFT_Rectangle(0, 0, 70, 25);
  // Extract the ST bit from Status(x0A) register.
  ST_bit = shadowReg[0] & 0x01;
  if (ST_bit > 0) {
    // Prepare Stereo icon
    Image1.Picture_Name = &icon_stereo_BMP;
    DrawImage(&Image1);
    // Change caption to Stereo
    strcpy(lblStereo_Caption, "Stereo");
    DrawLabel(&lblStereo);
  }
  else {
    // Prepare Mono icon
    Image1.Picture_Name = &icon_mono_BMP;
    DrawImage(&Image1);
    // Change caption to Mono
    strcpy(lblStereo_Caption, "Mono");
    DrawLabel(&lblStereo);
  }
}

void Refresh_MHz() {
unsigned int freq;
char txt[6];
char  ST_bit = 0;
  
  FM_Read(_FM_0A0B_REG_);
  freq = shadowReg[3]  + 875;                // Begining of Europe band 87.5 Mhz = 875 * 100kHz
  if (oldFreq != freq) {
    oldFreq = freq;
    WordToStr(freq, txt);                    // Populate string
    Ltrim(txt);
    if (txt[3] == 0){                        // Conversion for three digit values
      txt[4] = 0;
      txt[3] =  txt[2];
      txt[2] = '.';
    }
    else{
      txt[5] = 0;                            // Conversion for four digit values
      txt[4] =  txt[3];
      txt[3] = '.';
    }
    strcpy(txtFreq_Caption, txt);
    DrawButton(&txtFreq);
  }
  Update_StereoIcon();
  Set_Tunner(freq);
}

void FM_Tune(unsigned int freq, unsigned short dir) {
unsigned int calc;
char STC_bit = 0;
  // If tune in frequency is valid use it for direct tuingin
  if ( ( freq > 874 ) && (freq < 1081 ) )
    calc = freq;
  else {        // If frequency is not valid(=0), use direction value to change FM frequency
    FM_Read(_FM_0A0B_REG_);
    calc = shadowReg[3] + 875;
    if(dir == _FM_DIR_UP_) {
      if( calc < 1080 )
        calc++;         // Frequency in renge, increment current frequency
      else
        calc = 875;     // Start from beginning 87.5MHz
    }
    else {
       if( calc > 875)
         calc--;        // Frequency in renge, decrement current frequency
       else
         calc = 1080;   // Start from the top 108.0MHz
    }
  }
  ModShadowReg(0x03, 0x83FF, _RESET_); // Clear CHANNEL register in shadow reg.
  calc -= 875;
  calc |= 0x8000;                      // Set TUNE Flag
  if (powerON == 1) {                  // Check for power state of FM click
    FM_Write(0x03, calc, _SET_);       // Write modifiled frequency value
    Delay_ms(60);
    while (STC_bit == 0) {
      FM_Read(_FM_0A0B_REG_);
      STC_bit = shadowReg[0] & 0x40;
    }
    FM_Write(0x03, 0x8000, _RESET_);   // Set TUNE = 0;
    while (STC_bit > 0) {
      FM_Read(_FM_0A0B_REG_);
      STC_bit = shadowReg[0] & 0x40;
    }
    Refresh_MHz();                     // Update displayed information
  }
  else {
    ModShadowReg(0x03, calc, _SET_); // If power is off, only modify the shadow register
  }
}

void FM_Seek(unsigned short dir) {
char STC_bit = 0;
char ST_bit = 0;
char SF_BL_bit = 0;

  if (dir == _FM_DIR_UP_)
    FM_Write(0x02, 0x0300, _SET_);       // Activate SEEK
  else if (dir == _FM_DIR_DOWN_) {
    modShadowReg(0x02, 0x0200, _RESET_); // Set seek direction Down
    FM_Write(0x02, 0x0100, _SET_);       // Activate SEEK
  }
  
  while( STC_bit == 0 ) {
    Refresh_MHz();
    STC_bit = shadowReg[0] << 1;
    STC_bit >>= 7;
    Delay_ms(60);
  }
  SF_BL_bit = shadowReg[0] & 20;
  
  FM_Write(0x02, 0x0100, _RESET_);       // Deactivate SEEK
  
  while( STC_bit > 0 ) {
    FM_Read(_FM_0A0B_REG_);
    STC_bit = shadowReg[0] << 1;
    STC_bit >>= 3;
  }
  // Clear Stereo Icon
  TFT_Set_Brush(1, 0x3186, 0, 0, 0, 0);
  TFT_Rectangle(0, 0, 70, 25);
  
  if (SF_BL_bit == 0) {
    FM_Read(_FM_0A0B_REG_);
    Update_StereoIcon();
  }
}

char FM_Activate() {
unsigned int active;

  active = ChipID;
  FM_Write(0x02, 0x4001, _SET_);         // Write ENABLE bit
  Delay_ms(200);
  while (active == ChipID) {             // Wait for module powerup
    FM_Read(_FM_ALL_REG_);
    active = shadowReg[14] << 8;
    active |= shadowReg[15];
  }
  Delay_ms(200);
  modShadowReg(0x05, 0xFFFF, _RESET_);   // Write default Volume and RSSI Seek Threshold values
  FM_Write(0x05, 0x1015, _SET_);
  Volume = 5 * 23;
  Delay_ms(60);
  // Update GUI
  powerOn = 1;                           // Update powerOn flag
  imgVol.Active      = 1;                // Activate control buttons
  imgSeekDown.Active = 1;                //
  imgFineDown.Active = 1;                //
  imgFineUp.Active   = 1;                //
  imgSeekUp.Active   = 1;                //
  imgStop.Picture_Name = btn_stop_01_bmp;
  DrawImage(&imgStop);
  
  return (shadowReg[0]);
}

void FM_Deactivate() {
  modShadowReg(0x02,  0x4000, _RESET_ );
  FM_Write(0x02, 0x0041, _SET_);
  // Update GUI
  imgVol.Active      = 0;                // Deactivate control buttons
  imgSeekDown.Active = 0;                //
  imgFineDown.Active = 0;                //
  imgFineUp.Active   = 0;                //
  imgSeekUp.Active   = 0;                //
  powerOn = 0;                           // Updare powerOn flag
  imgStop.Picture_Name = bnt_play_01_bmp;
  DrawImage(&imgStop);
}

void FMClick_Init() {
  FM_RST  = 0;
  Delay_1ms();
  FM_RST = 1;
  Delay_1ms();
  FM_Read(_FM_ALL_REG_);
  ChipID = shadowReg[14] << 8;           // Save Chip ID befor powerup.
  ChipID |= shadowReg[15];
  Delay_1ms();
  FM_Write(0x07, 0x8100, _SET_);         // Activate Crystal Oscillator
  Delay_ms(500);
}

void PreConfig() {
  GPIO_Digital_Output(&GPIOA_BASE, _GPIO_PINMASK_15);
  GPIO_Digital_Output(&GPIOB_BASE, _GPIO_PINMASK_1 | _GPIO_PINMASK_12);
  GPIO_Digital_Output(&GPIOE_BASE, _GPIO_PINMASK_2);
  I2C2_Init_Advanced(100000, &_GPIO_MODULE_I2C2_PF01);  // Initialize I2C module for communication with FM Click board
  FM_SCK  = 1;
  FM_GP1  = 1;
  FM_SEN  = 1;
  FM_SDIO = 0;
  FM_RST  = 0;
}

void main() {
  PreConfig();
  Start_TP();
  Roller_Init();
  FMClick_Init();

  modShadowReg(0x02,  0x4000, _RESET_ );
  FM_Write(0x02, 0x0041, _SET_);
  Delay_ms(10);
  while (FM_Activate() == 0){
    Delay_ms(10);
    FMClick_Init();
  }
  FM_Tune(875, 0);
  Set_Tunner(875);
  
  // Initialize Buzzer
  Sound_Init(&GPIOB_ODR, 8);
  while (1) {
    Check_TP();
    if (!STMPE610_PressDetect()) {
      if (Roll_flag == 1){
        Roll_flag = 0;
        mylevel = doTunner();
        if ( ( mylevel >= 0 ) && ( mylevel < 10 ) )
          Set_Tunner(875);
        if ( mylevel > 214 )
          Set_Tunner(1080);
        if (mylevel != my_old_level){
          my_old_level = mylevel;
          channel = 875 + (mylevel - channel_offset);
          if ( ( channel > 874 ) && ( channel < 1081 ) ) {
            FM_Tune(channel, 0);
          }
        }
      }
    }
  }
}
