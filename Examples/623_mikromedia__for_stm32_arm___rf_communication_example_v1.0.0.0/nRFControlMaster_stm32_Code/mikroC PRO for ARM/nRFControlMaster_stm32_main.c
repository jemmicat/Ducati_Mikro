/*
 * Project name:
     nRFControlMaster_stm32.vtft
 * Generated by:
     Visual TFT
 * Date of creation
     3/29/2013
 * Time of creation
     2:07:57 PM
 * Test configuration:
     MCU:             STM32F407ZG
     Dev.Board:       Mikromedia_Plus_for_STM32_ARM
                      http://www.mikroe.com/mikromedia/plus/stm32-m4/
     Oscillator:      150000000 Hz
     SW:              mikroC PRO for ARM
                      http://www.mikroe.com/mikroc/arm/
 */

#include "nRFControlMaster_stm32_objects.h"
#include "__Lib_nRF24L01.h"
#include "nRF24L01_defs.h"
#include "led_protocol.h"

/**************************************************************************************************
* LEDs
**************************************************************************************************/
sfr sbit LED_R at GPIOG_ODR.B15;
sfr sbit LED_G at GPIOB_ODR.B3;
sfr sbit LED_B at GPIOB_ODR.B4;

/**************************************************************************************************
* nRF24L01+ connections
**************************************************************************************************/
sfr sbit nRF_CS    at GPIOG_ODR.B9;
sfr sbit nRF_CE    at GPIOG_ODR.B12;
sfr sbit nRF_IRQ   at GPIOG_IDR.B10;

TnRF_Status nRFStatus;
TRF_Config rfConfig;

unsigned char rfState;

TLed leds[8];

TButton_Round *btns[8];

void InitLeds(void) {
  unsigned char i;

  for (i = 0; i < 8; i++)
  {
    leds[i]._state = 0;
    leds[i]._no    = i;
  }
}

void InitTimer2(){
  // Initialize TIMER2 module for CE pulse
  RCC_APB1ENR.TIM2EN = 1;       // Enable clock gating for timer module 2
  TIM2_CR1.CEN = 0;             // Disable timer
  TIM2_PSC = 0;                 // Set timer prescaler.
  TIM2_ARR = 2400;
  NVIC_IntEnable(IVT_INT_TIM2); // Enable timer interrupt
  TIM2_DIER.UIE = 1;            // Update interrupt enable

  TIM2_CR1.CEN = 0;
}

void InitExt(){
  SYSCFGEN_bit = 1;                    // Enable clock for alternate pin functions
  SYSCFG_EXTICR3 = 0x00000600;         // Map external interrupt on PG10
  EXTI_RTSR = 0x00000000;              // Set interrupt on Rising edge (none)
  EXTI_FTSR = 0x00000400;              // Set Interrupt on Falling edge (PG10)
  EXTI_IMR |= 0x00000400;              // Set mask

  NVIC_IntEnable(IVT_INT_EXTI15_10);   // Enable External interrupt
}

void Timer2_interrupt() iv IVT_INT_TIM2 ics ICS_AUTO
{
  TIM2_SR.UIF = 0;
  TIM2_CR1.CEN = 0;
  TIMER2_IRQ();
  TIM2_CR1.CEN = 0;
}

// External interrupt
void ExtInt() iv IVT_INT_EXTI15_10 ics ICS_AUTO
{
  EXTI_PR.B10 = 1;                      // clear flag
  nRF24L01_IRQ();
}


void InitRF()
{
  GPIO_Digital_Output(&GPIOB_BASE, _GPIO_PINMASK_3 | _GPIO_PINMASK_4);
  GPIO_Digital_Output(&GPIOG_BASE, _GPIO_PINMASK_15);

  nRF_CE = 0;
  nRF_CS = 1;

  InitTimer2();
  InitExt();

  // Initialize SPI1 module
  SPI2_Init_Advanced(_SPI_FPCLK_DIV16, _SPI_MASTER  | _SPI_8_BIT |
                     _SPI_CLK_IDLE_LOW | _SPI_FIRST_CLK_EDGE_TRANSITION |
                     _SPI_MSB_FIRST | _SPI_SS_DISABLE | _SPI_SSM_ENABLE | _SPI_SSI_1,
                     &_GPIO_MODULE_SPI2_PB13_14_15);
}

void main() {
  btns[0] = &ButtonRound8;
  btns[1] = &ButtonRound7;
  btns[2] = &ButtonRound6;
  btns[3] = &ButtonRound5;
  btns[4] = &ButtonRound4;
  btns[5] = &ButtonRound3;
  btns[6] = &ButtonRound2;
  btns[7] = &ButtonRound1;

  InitLeds();
  
  //nRF Config Settings
  rfConfig.autoTransmitDelay = nRF_AUTO_RETRANSMIT_DELAY_4000us; 
  rfConfig.autoTransmitCount = nRF_AUTO_RETRANSMIT_COUNT_05;
  rfConfig.channel           = 64;
  rfConfig.outputPower       = nRF_OUTPUT_POWER_0dBm;
  rfConfig.dataRate          = nRF_DATA_RATE_1Mbps;

  Start_TP();
  
  nRF_Init();
  InitRF();
  Delay_ms(100);

  rfState = RF_STOP;

  nRF_TX_Mode_Init_Advanced(rfConfig.dataRate, rfConfig.autoTransmitDelay, rfConfig.autoTransmitCount, rfConfig.outputPower, rfConfig.channel);


  while (1) {
    Check_TP();
    
    if(rfState == RF_SEND_CMD)
    {
      if(nRF_Send_Packet())
      {
        LED_R = ~LED_R;
        Delay_ms(10);
        nRF_Process(&nRFStatus);

        if(nRFStatus._status == nRF_TX_DS)
        {
          LED_B = ~LED_B;
          LED_R = 0;

          rfState = RF_STOP;
        }
      }
    }
  }
}
